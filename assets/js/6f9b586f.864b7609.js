"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[7653],{8453:(e,n,t)=>{t.d(n,{R:()=>i,x:()=>o});var a=t(6540);const s={},r=a.createContext(s);function i(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:i(e.components),a.createElement(r.Provider,{value:n},e.children)}},9309:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>i,default:()=>h,frontMatter:()=>r,metadata:()=>o,toc:()=>d});var a=t(4848),s=t(8453);const r={title:"5.4 - Updating Objects and Arrays in State",metadata:["Can be provided",{as:"objects",or:"arrays"}]},i=void 0,o={id:"Readings/react-state/5.4",title:"5.4 - Updating Objects and Arrays in State",description:"---",source:"@site/docs/Readings/5-react-state/5.4.md",sourceDirName:"Readings/5-react-state",slug:"/Readings/react-state/5.4",permalink:"/docs/Readings/react-state/5.4",draft:!1,unlisted:!1,editUrl:"https://github.com/CS61D/website/tree/main/docs/Readings/5-react-state/5.4.md",tags:[],version:"current",frontMatter:{title:"5.4 - Updating Objects and Arrays in State",metadata:["Can be provided",{as:"objects",or:"arrays"}]},sidebar:"tutorialSidebar",previous:{title:"5.3 - State and Component Memory",permalink:"/docs/Readings/react-state/5.3"},next:{title:"TypeScript",permalink:"/docs/Readings/typescript"}},l={},d=[{value:"Copying objects with spread syntax",id:"copying-objects-with-spread-syntax",level:3},{value:"Recap",id:"recap",level:4},{value:"Updating Arrays in State",id:"updating-arrays-in-state",level:3},{value:"Updating Arrays without Mutation",id:"updating-arrays-without-mutation",level:4}];function c(e){const n={a:"a",admonition:"admonition",code:"code",h3:"h3",h4:"h4",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.p,{children:"State can hold any kind of JavaScript value, including objects. But you shouldn\u2019t change objects that you hold in the React state directly\u2013instead, to update an object, you need to create a new instance (or make a copy), and then set the state to use that copy."}),"\n",(0,a.jsx)(n.admonition,{type:"warning",children:(0,a.jsx)(n.p,{children:"Although objects in React state are technically mutable, you should treat them as if they were immutable\u2014like numbers, booleans, and strings. Instead of mutating them, you should always replace them."})}),"\n",(0,a.jsx)(n.p,{children:"This example holds an object in state to represent the current pointer position. The red dot is supposed to move when you touch or move the cursor over the preview area. But this code is buggy: the dot always stays in the initial position:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import { useState } from "react";\nexport default function MovingDot() {\n  const [position, setPosition] = useState({\n    x: 0,\n    y: 0,\n  });\n  return (\n    <div\n      onPointerMove={(e) => {\n        position.x = e.clientX;\n        position.y = e.clientY;\n      }}\n    >\n      <div\n        style={{\n          position: "absolute",\n          backgroundColor: "red",\n          borderRadius: "50%",\n          transform: `translate(${position.x}px, ${position.y}px)`,\n          left: -10,\n          top: -10,\n          width: 20,\n          height: 20,\n        }}\n      />\n    </div>\n  );\n}\n'})}),"\n",(0,a.jsx)(n.p,{children:"The problem is with this bit of code."}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"onPointerMove={e => {\n  position.x = e.clientX;\n  position.y = e.clientY;\n}}\n"})}),"\n",(0,a.jsx)(n.p,{children:"This code modifies the object assigned to position from the previous render. But without using the state setting function, React has no idea that object has changed. So React does not do anything in response. It\u2019s like trying to change the order after you\u2019ve already eaten the meal."}),"\n",(0,a.jsx)(n.p,{children:"To actually trigger a re-render in this case, create a new object and pass it to the state setting function:"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"onPointerMove={e => {\n  setPosition({\n    x: e.clientX,\n    y: e.clientY\n  });\n}}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"setPosition"}),", you\u2019re telling React:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Replace ",(0,a.jsx)(n.code,{children:"position"})," with this new object"]}),"\n",(0,a.jsx)(n.li,{children:"And render this component again"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"Now the code should work as intended: the red dot should follow your cursor."}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"copying-objects-with-spread-syntax",children:"Copying objects with spread syntax"}),"\n",(0,a.jsx)(n.p,{children:"In the previous example, the position object is always created fresh from the current cursor position. But often, you will want to include existing data as a part of the new object you\u2019re creating. For example, you may want to update only one field in a form, but keep the previous values for all other fields."}),"\n",(0,a.jsxs)(n.p,{children:["These input fields don\u2019t work because the ",(0,a.jsx)(n.code,{children:"onChange"})," handlers mutate the state:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"onPointerMove={e => {\n  setPosition({\n    x: e.clientX,\n    y: e.clientY\n  });\n}}\n"})}),"\n",(0,a.jsxs)(n.p,{children:["With ",(0,a.jsx)(n.code,{children:"setPosition"}),", you\u2019re telling React:"]}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:["Replace ",(0,a.jsx)(n.code,{children:"position"})," with this new object"]}),"\n",(0,a.jsx)(n.li,{children:"And render this component again"}),"\n"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:'import { useState } from "react";\n\nexport default function Form() {\n  const [person, setPerson] = useState({\n    firstName: "Elaine",\n    lastName: "S",\n    email: "elaineS@berkeley.edu",\n  });\n  // these don\'t work because they are mutating the state from a past render.\n\n  function handleFirstNameChange(e) {\n    person.firstName = e.target.value;\n  }\n\n  function handleLastNameChange(e) {\n    person.lastName = e.target.value;\n  }\n\n  function handleEmailChange(e) {\n    person.email = e.target.value;\n  }\n\n  return (\n    <>\n      <label>\n        First name:\n        <input value={person.firstName} onChange={handleFirstNameChange} />\n      </label>\n      <label>\n        Last name:\n        <input value={person.lastName} onChange={handleLastNameChange} />\n      </label>\n      <label>\n        Email:\n        <input value={person.email} onChange={handleEmailChange} />\n      </label>\n      <p>\n        {person.firstName} {person.lastName} ({person.email})\n      </p>\n    </>\n  );\n}\n'})}),"\n",(0,a.jsxs)(n.p,{children:["The reliable way to get the behavior you\u2019re looking for is to create a new object and pass it to ",(0,a.jsx)(n.code,{children:"setPerson"}),". But here, you want to also copy the existing data into it because only one of the fields has changed:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"setPerson({\n  firstName: e.target.value, // New first name from the input\n  lastName: person.lastName,\n  email: person.email,\n});\n"})}),"\n",(0,a.jsxs)(n.p,{children:["You can use the ",(0,a.jsx)(n.code,{children:"..."})," object spread syntax so that you don\u2019t need to copy every property separately."]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-jsx",children:"setPerson({\n  ...person, // Copy the old fields\n  firstName: e.target.value, // But override this one\n});\n"})}),"\n",(0,a.jsx)(n.p,{children:"Notice how you didn\u2019t declare a separate state variable for each input field. For large forms, keeping all data grouped in an object is very convenient\u2014as long as you update it correctly!"}),"\n",(0,a.jsx)(n.h4,{id:"recap",children:"Recap"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Treat all state in React as immutable."}),"\n",(0,a.jsx)(n.li,{children:"When you store objects in state, mutating them will not trigger renders and will change the state in previous render \u201csnapshots\u201d."}),"\n",(0,a.jsx)(n.li,{children:"Instead of mutating an object, create a new version of it, and trigger a re-render by setting state to it."}),"\n",(0,a.jsxs)(n.li,{children:["You can use the ",(0,a.jsx)(n.code,{children:"{...obj, something: 'newValue'}"})," object spread syntax to create copies of objects."]}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsx)(n.h3,{id:"updating-arrays-in-state",children:"Updating Arrays in State"}),"\n",(0,a.jsx)(n.p,{children:"Arrays are mutable in JavaScript, but you should treat them as immutable when stored in state. This means when you need to update an array in state, you must create a new instance and then set state to use the new array."}),"\n",(0,a.jsx)(n.h4,{id:"updating-arrays-without-mutation",children:"Updating Arrays without Mutation"}),"\n",(0,a.jsxs)(n.p,{children:["In JavaScript, arrays are just another kind of object. Like with objects, you should treat arrays in React state as ",(0,a.jsx)(n.strong,{children:"read-only"}),". This means that you shouldn\u2019t reassign items inside an array like ",(0,a.jsx)(n.code,{children:"arr[0] = 'bird'"}),", and you also shouldn\u2019t use methods that mutate the array, such as ",(0,a.jsx)(n.code,{children:"push()"})," and ",(0,a.jsx)(n.code,{children:"pop()"}),"."]}),"\n",(0,a.jsxs)(n.p,{children:["Instead,you can create a new array from the original array in your state by calling its non-mutating methods like ",(0,a.jsx)(n.code,{children:"filter()"})," and ",(0,a.jsx)(n.code,{children:"map()"}),". Then you can set your state to the resulting new array."]}),"\n",(0,a.jsx)(n.p,{children:"Here is a reference table of common array operations. When dealing with arrays inside React state, you will need to avoid the methods in the left column, and instead prefer the methods in the right column:"}),"\n",(0,a.jsxs)(n.table,{children:[(0,a.jsx)(n.thead,{children:(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.th,{children:"Operation"}),(0,a.jsx)(n.th,{children:"Avoid (mutates the array)"}),(0,a.jsx)(n.th,{children:"Prefer (returns a new array)"})]})}),(0,a.jsxs)(n.tbody,{children:[(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Adding"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"push"}),", ",(0,a.jsx)(n.code,{children:"unshift"})]}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"concat"}),", ",(0,a.jsx)(n.code,{children:"[...arr]"})," spread syntax ",(0,a.jsxs)(n.a,{href:"https://react.dev/learn/updating-arrays-in-state#adding-to-an-array",rel:"nofollow",children:["(example)",(0,a.jsx)(n.span,{children:(0,a.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Removing"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"pop"}),", ",(0,a.jsx)(n.code,{children:"shift"}),", ",(0,a.jsx)(n.code,{children:"splice"})]}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"filter"}),", ",(0,a.jsx)(n.code,{children:"slice"})," ",(0,a.jsxs)(n.a,{href:"https://react.dev/learn/updating-arrays-in-state#removing-from-an-array",rel:"nofollow",children:["(example)",(0,a.jsx)(n.span,{children:(0,a.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Replacing"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"splice"}),", ",(0,a.jsx)(n.code,{children:"arr[i] = ..."})," assignment"]}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"map"})," ",(0,a.jsxs)(n.a,{href:"https://react.dev/learn/updating-arrays-in-state#replacing-items-in-an-array",rel:"nofollow",children:["(example)",(0,a.jsx)(n.span,{children:(0,a.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Sorting"}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"reverse"}),", ",(0,a.jsx)(n.code,{children:"sort"})]}),(0,a.jsxs)(n.td,{children:["Copy the array first ",(0,a.jsxs)(n.a,{href:"https://react.dev/learn/updating-arrays-in-state#making-other-changes-to-an-array",rel:"nofollow",children:["(example)",(0,a.jsx)(n.span,{children:(0,a.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})]})]}),(0,a.jsxs)(n.tr,{children:[(0,a.jsx)(n.td,{children:"Inserting"}),(0,a.jsx)(n.td,{children:(0,a.jsx)(n.code,{children:"splice"})}),(0,a.jsxs)(n.td,{children:[(0,a.jsx)(n.code,{children:"[...arr.slice(0, index), newItem, ...arr.slice(index)]"})," ",(0,a.jsxs)(n.a,{href:"https://react.dev/learn/updating-arrays-in-state#inserting-into-an-array",rel:"nofollow",children:["(example)",(0,a.jsx)(n.span,{children:(0,a.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})]})]})]})]}),"\n",(0,a.jsxs)(n.admonition,{type:"warning",children:[(0,a.jsxs)(n.p,{children:["Unfortunately, ",(0,a.jsx)(n.code,{children:"slice"})," and ",(0,a.jsx)(n.code,{children:"splice"})," are named similarly but are very different:"]}),(0,a.jsxs)(n.p,{children:[(0,a.jsx)(n.code,{children:"slice"})," lets you copy an array or a part of it.\n",(0,a.jsx)(n.code,{children:"splice"})," mutates the array (to insert or delete items)."]}),(0,a.jsxs)(n.p,{children:["In React, you will be using ",(0,a.jsx)(n.code,{children:"slice"})," (no p!) a lot more often because you don\u2019t want to mutate objects or arrays in state."]})]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(c,{...e})}):c(e)}}}]);