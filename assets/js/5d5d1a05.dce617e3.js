"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2680],{6947:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>p,frontMatter:()=>i,metadata:()=>o,toc:()=>l});var t=r(4848),s=r(8453);const i={sidebar_position:5},a="TypeScript",o={id:"Readings/typescript",title:"TypeScript",description:"Links",source:"@site/docs/Readings/typescript.md",sourceDirName:"Readings",slug:"/Readings/typescript",permalink:"/docs/Readings/typescript",draft:!1,unlisted:!1,editUrl:"https://github.com/CS61D/website/tree/main/docs/Readings/typescript.md",tags:[],version:"current",sidebarPosition:5,frontMatter:{sidebar_position:5},sidebar:"tutorialSidebar",previous:{title:"5.4 - Updating Objects and Arrays in State",permalink:"/docs/Readings/react-state/5.4"},next:{title:"Lecture 6: Advanced State Management",permalink:"/docs/Readings/advanced-state-management/"}},c={},l=[{value:"Links",id:"links",level:2},{value:"Why TypeScript?",id:"why-typescript",level:2},{value:"Primitive Types and Type Errors",id:"primitive-types-and-type-errors",level:2},{value:"Typing Arrays, Objects, and Functions",id:"typing-arrays-objects-and-functions",level:2},{value:"Unions and Type Inference",id:"unions-and-type-inference",level:2},{value:"Discriminated Unions",id:"discriminated-unions",level:3},{value:"Generics",id:"generics",level:2},{value:"Unused TypeScript Features",id:"unused-typescript-features",level:2}];function d(e){const n={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",img:"img",li:"li",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"typescript",children:"TypeScript"}),"\n",(0,t.jsx)(n.h2,{id:"links",children:"Links"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://www.youtube.com/watch?v=C3CzIBC5YwI",rel:"nofollow",children:["TypeScript Lecture",(0,t.jsx)(n.span,{children:(0,t.jsx)(n.img,{src:"/img/link-icons/youtube.svg",alt:"youtube",className:"glossary-icon",style:{width:"16px",height:"16px",marginLeft:"0.25rem",verticalAlign:"baseline"}})})]})}),"\n",(0,t.jsx)(n.li,{children:(0,t.jsxs)(n.a,{href:"https://github.com/CS61D/Lecture-TypeScript",rel:"nofollow",children:["TypeScript Lecture Code",(0,t.jsx)(n.span,{children:(0,t.jsx)(n.img,{src:"/img/link-icons/github.svg",alt:"github",className:"github-icon",style:{width:"16px",height:"16px",marginLeft:"0.25rem",verticalAlign:"baseline"}})})]})}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"why-typescript",children:"Why TypeScript?"}),"\n",(0,t.jsxs)(n.p,{children:["In ",(0,t.jsx)(n.a,{href:"/docs/Readings/javascript#why-javascript",children:"why JavaScript"}),", we established that learning JavaScript is necessary for frontend, and a decent choice for backend. With that being said, dynamic typing is ",(0,t.jsx)(n.strong,{children:"terrible"})," for developer experience and productivity."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",children:'const numberArray = [1, 2, 3, 4];\nnumberArray.push("five"); // Oops!\nconst doubled = numberArray.map((val) => val * 2);\n// [ 2, 4, 6, 8, NaN ]\n'})}),"\n",(0,t.jsxs)(n.p,{children:["If we were using a statically types language, we would know for sure that our doubled array contains only numbers, and then could reason about it properly. So called ",(0,t.jsx)(n.em,{children:"type errors"})," are an entire class of bugs which only get worse as codebases expand in complexity."]}),"\n",(0,t.jsxs)(n.p,{children:["We can't change the fundamental way that JavaScript executes in the browser or on the server (runtime), but we can mimic the guarantees of a statically typed language by adding types that are checked before at ",(0,t.jsx)(n.a,{href:"/docs/glossary#compile-time",children:"compile time"}),". JavaScript with the addition of types is called TypeScript, which has become the industry standard way of writing JavaScript."]}),"\n",(0,t.jsx)(n.h2,{id:"primitive-types-and-type-errors",children:"Primitive Types and Type Errors"}),"\n",(0,t.jsx)(n.p,{children:"The basic TypeScript types are strings, numbers, booleans, undefined, and null. These types can then be used in arrays and objects."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'let name: string = "Aidan";\nlet age: number = 21;\nlet isMale: boolean = true;\n'})}),"\n",(0,t.jsx)(n.p,{children:"Once a variable is assigned a type, attempting to reassign it to a value of a different type will throw a type error."}),"\n",(0,t.jsx)(n.p,{children:(0,t.jsx)(n.img,{alt:"type error",src:r(5150).A+"",width:"621",height:"234"})}),"\n",(0,t.jsx)(n.p,{children:"Type errors appear interactively in your editor, but you can also run the TypeScript compiler from you terminal."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-bash",children:"bunx tsc file.ts --noEmit # Individual file\nbunx tsc --noEmit # Entire directory\n"})}),"\n",(0,t.jsx)(n.h2,{id:"typing-arrays-objects-and-functions",children:"Typing Arrays, Objects, and Functions"}),"\n",(0,t.jsxs)(n.p,{children:["Objects can be typed by specifying a type for each of their properties. Optional properties can be specified with a ",(0,t.jsx)(n.code,{children:"?"}),". When an object is defined with a type, it must have all the properties of that type."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"export type Person = {\n  name: string;\n  age: number;\n  grade?: number; // Optional type\n  // equivalent to number | undefined\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Object types can be also be extended to create new types based on existing types."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// Inherit all of the fields of the Person type, and add a grade field\nexport type Student = Person & {\n  grade: number;\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Arrays can be typed by specifying the type of their elements in square brackets. Items accessed from the array will have the type of the array, and only items of the array type can be added to the array."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'let firstNames: string[] = ["Aidan", "Bob", "Charlie"];\n\n// Alternate syntax\nconst lastNames: Array<string> = ["Smith", "Johnson", "Williams"];\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Functions must have their input parameters typed, but the return type is ",(0,t.jsx)(n.em,{children:"inferred"})," by TypeScript. Even though we never specify the return type of ",(0,t.jsx)(n.code,{children:"isOdd"}),", TypeScript can infer that it returns a boolean, meaning there is no type error when we assign the result to a boolean variable."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const isOdd = (num: number) => {\n  return num % 2 === 1;\n};\n\nconst shouldContinue: boolean = isOdd(3);\n"})}),"\n",(0,t.jsx)(n.p,{children:"While explicit function return types can be specified, doing so is actively harmful. If the explicitly specified return type of a function does not match the inferred return type, TypeScript will throw just one type error for the function. If the function is then used throughout you code base, the explicit return type will be used and later type errors will not be caught."}),"\n",(0,t.jsx)(n.p,{children:"The only time you should specify a return type is when you are defining the parameters of a higher order function. This is so that TypeScript can infer the return type of the function passed to the higher order function."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const transformOddStrings = (\n  array: string[],\n  func: (input: string) => string, // Higher order function must take and return a string\n) => array.map((val, index) => (index % 2 == 1 ? func(val) : val));\n"})}),"\n",(0,t.jsx)(n.h2,{id:"unions-and-type-inference",children:"Unions and Type Inference"}),"\n",(0,t.jsxs)(n.p,{children:["TypeScript types can be combined, such that a type is of one type ",(0,t.jsx)(n.em,{children:"or"})," another. These type unions are specified with the ",(0,t.jsx)(n.code,{children:"|"})," operator."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'type Person = {\n  name: string;\n  age: number;\n};\n\nconst birthdayWish = (person: Person | null) => {\n  if (person === null) {\n    return "Happy Birthday Stranger";\n  }\n  return `Happy ${person.age}th birthday ${person.name}`;\n};\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The above example also illustrates TypeScript's type inference. After the ",(0,t.jsx)(n.code,{children:"if"})," statement has run, TypeScript has ",(0,t.jsx)(n.em,{children:"narrowed"})," the type of ",(0,t.jsx)(n.code,{children:"Person | null"})," to just ",(0,t.jsx)(n.code,{children:"Person"}),". This means that we can safely access the ",(0,t.jsx)(n.code,{children:"name"})," and ",(0,t.jsx)(n.code,{children:"age"})," properties of ",(0,t.jsx)(n.code,{children:"person"})," without a type error."]}),"\n",(0,t.jsx)(n.p,{children:"Type unions are particularly useful when combined with type literals."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:'// The role can not be any string, it must be one of the specified strings\ntype Roles = "Admin" | "Manager" | "User";\n\n// Check if action is permitted based on user role and required role of action\nconst permittedRoles = (userRole: Roles, requiredRole: Roles) => {\n  if (requiredRole === "User") {\n    return true;\n  }\n\n  if (requiredRole === "Manager") {\n    return userRole === "Manager" || userRole === "Admin";\n  }\n\n  return userRole === "Admin";\n};\n'})}),"\n",(0,t.jsx)(n.h3,{id:"discriminated-unions",children:"Discriminated Unions"}),"\n",(0,t.jsxs)(n.p,{children:["A particularly useful type of union is one where the type of the object can be determined by checking a common ",(0,t.jsx)(n.em,{children:"discriminator"})," key."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"// A 401 error means that the user is not authenticated (signed in)\n// A 403 error means that the user does not have the required permission\n// A 429 error means that the user has made too many requests and is being rate limited\ntype ErrorResponse =\n  | {\n      code: 401;\n      message: string;\n    }\n  | {\n      code: 403;\n      message: string;\n      requiredPermission: string;\n    }\n  | {\n      code: 429;\n      message: string;\n      retryAfter: string;\n    };\n\nconst handleError = (error: ErrorResponse) => {\n  if (error.code === 403) {\n    console.log(`You need permission ${error.requiredPermission}`);\n  } else if (error.code === 429) {\n    console.log(`Too many requests, try again at ${error.retryAfter}`);\n  }\n\n  // The message field is always present\n  return error.message;\n};\n"})}),"\n",(0,t.jsx)(n.p,{children:"Arbitrarily large and complex unions of objects can be immediately narrowed down if they all share a unique discriminator key."}),"\n",(0,t.jsx)(n.h2,{id:"generics",children:"Generics"}),"\n",(0,t.jsxs)(n.p,{children:["Let's revisit some of the array functions we have been using. How would we implement our own version of the ",(0,t.jsx)(n.code,{children:"map"})," function?"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const myMap = (array: number[], func: (val: number) => number) => {\n  const result: number[] = [];\n  for (const val of array) {\n    result.push(func(val));\n  }\n  return result;\n};\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This implementation is fine, but it will throw a type error if we try and use an array of strings. How does the builtin ",(0,t.jsx)(n.code,{children:"map"})," function handle this?"]}),"\n",(0,t.jsxs)(n.p,{children:["The answer is that it is a ",(0,t.jsx)(n.code,{children:"generic"})," function. Generic functions essentially take a type as a parameter. This type can then be used throughout the function to ensure that the function is type safe."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"const myMapGeneric = <T>(array: T[], func: (val: T) => T) => {\n  const result: T[] = [];\n  for (const val of array) {\n    result.push(func(val));\n  }\n  return result;\n};\n\n// This is okay. Our <T> type parameter is inferred to be number\nconst doubled = myMapGeneric([1, 2, 3, 4], (val) => val * 2);\n\n// This is not okay because the generic Type must be the same for the array and the function\nconst doubledStrings = myMapGeneric([1, 2, 3, 4], (val) => val.toString());\n"})}),"\n",(0,t.jsx)(n.h2,{id:"unused-typescript-features",children:"Unused TypeScript Features"}),"\n",(0,t.jsx)(n.p,{children:"There are several functionalities of TypeScript which we do not recommend using yourself, but which you still should be able to recognize if you see them in someone else' code."}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Interfaces"})," are an alternative way of declaring types. They function almost the exact same as types, but have a slightly different syntax."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"interface PersonInterface {\n  name: string;\n  age: number;\n}\n\n// Extending an interface\ninterface EmployeeInterface extends PersonInterface {\n  job: string;\n}\n"})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.em,{children:"Enums"})," are an alternative to type unions. They are a way of defining a set of named constants."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-typescript",children:"enum Direction {\n  Up,\n  Down,\n  Left,\n  Right,\n}\n\nlet go: Direction = Direction.Up;\n"})})]})}function p(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},5150:(e,n,r)=>{r.d(n,{A:()=>t});const t=r.p+"assets/images/type-error-cae0419f55a03aeff8f0e98e6f806780.png"},8453:(e,n,r)=>{r.d(n,{R:()=>a,x:()=>o});var t=r(6540);const s={},i=t.createContext(s);function a(e){const n=t.useContext(i);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function o(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),t.createElement(i.Provider,{value:n},e.children)}}}]);