"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2680],{2758:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>o,contentTitle:()=>c,default:()=>l,frontMatter:()=>i,metadata:()=>r,toc:()=>d});const r=JSON.parse('{"id":"Readings/typescript","title":"TypeScript","description":"Why TypeScript?","source":"@site/docs/Readings/typescript.md","sourceDirName":"Readings","slug":"/Readings/typescript","permalink":"/docs/Readings/typescript","draft":false,"unlisted":false,"editUrl":"https://github.com/CS61D/website/tree/main/docs/Readings/typescript.md","tags":[],"version":"current","sidebarPosition":5,"frontMatter":{"sidebar_position":5},"sidebar":"tutorialSidebar","previous":{"title":"5.4 - Updating Objects and Arrays in State","permalink":"/docs/Readings/react-state/5.4"},"next":{"title":"Lecture 6: Advanced State Management","permalink":"/docs/Readings/advanced-state-management/"}}');var a=n(4848),s=n(8453);const i={sidebar_position:5},c="TypeScript",o={},d=[{value:"Why TypeScript?",id:"why-typescript",level:2}];function p(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"typescript",children:"TypeScript"})}),"\n",(0,a.jsx)(t.h2,{id:"why-typescript",children:"Why TypeScript?"}),"\n",(0,a.jsxs)(t.p,{children:["In ",(0,a.jsx)(t.a,{href:"/docs/Readings/javascript#why-javascript",children:"why JavaScript"}),", we established that learning JavaScript is necessary for frontend, and a decent choice for backend. With that being said, dynamic typing is ",(0,a.jsx)(t.strong,{children:"terrible"})," for developer experience and productivity."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-javascript",children:'const numberArray = [1, 2, 3, 4];\nnumberArray.push("five"); // Oops!\nconst doubled = numberArray.map((val) => val * 2);\n// [ 2, 4, 6, 8, NaN ]\n'})}),"\n",(0,a.jsxs)(t.p,{children:["If we were using a statically types language, we would know for sure that our doubled array contains only numbers, and then could reason about it properly. So called ",(0,a.jsx)(t.em,{children:"type errors"})," are an entire class of bugs which only get worse as codebases expand in complexity."]}),"\n",(0,a.jsx)(t.p,{children:"We can't change the fundamental way that JavaScript executes in the browser or on the server (runtime), but we can mimic the guarantees of a statically typed language by adding types that are checked before our code executes (compile time). JavaScript with the addition of types is called TypeScript, which has become the industry standard way of writing JavaScript."})]})}function l(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(p,{...e})}):p(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>c});var r=n(6540);const a={},s=r.createContext(a);function i(e){const t=r.useContext(s);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function c(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),r.createElement(s.Provider,{value:t},e.children)}}}]);