"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[2018],{8453:(e,n,t)=>{t.d(n,{R:()=>s,x:()=>c});var a=t(6540);const i={},r=a.createContext(i);function s(e){const n=a.useContext(r);return a.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function c(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:s(e.components),a.createElement(r.Provider,{value:n},e.children)}},9860:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>o,contentTitle:()=>s,default:()=>u,frontMatter:()=>r,metadata:()=>c,toc:()=>d});var a=t(4848),i=t(8453);const r={title:"15.1 - React Query",metadata:["Can be provided",{as:"objects",or:"arrays"}]},s="15.1 - React Query",c={id:"Readings/trpc-on-the-client/15.1",title:"15.1 - React Query",description:"When working with tRPC on the client side, one of the key tools to know about is React Query. React Query helps manage server state in your React application, making it easier to fetch, cache, and sync data.",source:"@site/docs/Readings/15-trpc-on-the-client/15.1.md",sourceDirName:"Readings/15-trpc-on-the-client",slug:"/Readings/trpc-on-the-client/15.1",permalink:"/docs/Readings/trpc-on-the-client/15.1",draft:!1,unlisted:!1,editUrl:"https://github.com/CS61D/website/tree/main/docs/Readings/15-trpc-on-the-client/15.1.md",tags:[],version:"current",frontMatter:{title:"15.1 - React Query",metadata:["Can be provided",{as:"objects",or:"arrays"}]},sidebar:"tutorialSidebar",previous:{title:"Lecture 15 - tRPC on the Client",permalink:"/docs/Readings/trpc-on-the-client/"},next:{title:"15.2 - Loading and Error states",permalink:"/docs/Readings/trpc-on-the-client/15.2"}},o={},d=[{value:"What is React Query?",id:"what-is-react-query",level:2},{value:"Key Features of React Query",id:"key-features-of-react-query",level:3},{value:"How React Query Works",id:"how-react-query-works",level:2},{value:"Major Tools in React Query",id:"major-tools-in-react-query",level:3},{value:"React Query in Action",id:"react-query-in-action",level:2},{value:"Fetching Data with <code>useQuery</code>",id:"fetching-data-with-usequery",level:3},{value:"Query Keys",id:"query-keys",level:2},{value:"Handling Mutations with <code>useMutation</code>",id:"handling-mutations-with-usemutation",level:3},{value:"Manual Cache Management with <code>useQueryClient</code>",id:"manual-cache-management-with-usequeryclient",level:3},{value:"Invalidating Stale Data",id:"invalidating-stale-data",level:2}];function l(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.h1,{id:"151---react-query",children:"15.1 - React Query"}),"\n",(0,a.jsx)(n.p,{children:"When working with tRPC on the client side, one of the key tools to know about is React Query. React Query helps manage server state in your React application, making it easier to fetch, cache, and sync data."}),"\n",(0,a.jsx)(n.h2,{id:"what-is-react-query",children:"What is React Query?"}),"\n",(0,a.jsx)(n.p,{children:"React Query is a powerful library for fetching, caching, and synchronizing server state in React applications. It provides an intuitive API for handling asynchronous operations, such as data fetching and updating, while also managing the cache and background synchronization."}),"\n",(0,a.jsx)(n.h3,{id:"key-features-of-react-query",children:"Key Features of React Query"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Data Fetching"}),": Easily fetch data from APIs or other sources and handle the result with built-in hooks."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Caching"}),": Automatically cache data to avoid redundant requests and improve performance."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Background Syncing"}),": Automatically refetch data in the background to keep it fresh."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Pagination & Infinite Query"}),": Support for pagination and infinite scrolling to handle large datasets."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Mutations"}),": Simplified handling of creating, updating, and deleting data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Error Handling"}),": Integrated error handling for failed requests."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"how-react-query-works",children:"How React Query Works"}),"\n",(0,a.jsx)(n.p,{children:"React Query abstracts away much of the complexity involved in managing server state. It provides hooks that interact with a central cache, allowing your components to focus on rendering data rather than managing state or side effects."}),"\n",(0,a.jsx)(n.h3,{id:"major-tools-in-react-query",children:"Major Tools in React Query"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useQuery"})}),": Fetches data and manages loading, error, and data states."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useMutation"})}),": Handles creating, updating, or deleting data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useQueryClient"})}),": Provides access to the React Query client for manual cache management and invalidation."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"react-query-in-action",children:"React Query in Action"}),"\n",(0,a.jsxs)(n.h3,{id:"fetching-data-with-usequery",children:["Fetching Data with ",(0,a.jsx)(n.code,{children:"useQuery"})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useQuery"})," hook is used to fetch data from an API or other data source. Here\u2019s an example of how to use it with tRPC:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// src/hooks/useUser.ts\nimport { useQuery } from "react-query";\nimport { trpc } from "../utils/trpc";\n\nexport const useUser = (id: string) => {\n  return useQuery(["user", id], () => trpc.user.getUser.query({ id }));\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"In this example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useQuery"})," takes two arguments: a unique query key (",(0,a.jsx)(n.code,{children:"['user', id]"}),") and a function to fetch the data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"trpc.user.getUser.query"})," is used to call a tRPC procedure."]}),"\n"]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsx)(n.h2,{id:"query-keys",children:"Query Keys"}),(0,a.jsx)(n.p,{children:"Query keys are used to uniquely identify a query and its data in the cache. They are essential for:"}),(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Fetching Data"}),": React Query uses the query key to fetch and cache data."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Invalidating Data"}),": The key helps to target specific queries when invalidating the cache."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:"Refetching Data"}),": React Query can refetch data based on the query key."]}),"\n"]})]}),"\n",(0,a.jsxs)(n.h3,{id:"handling-mutations-with-usemutation",children:["Handling Mutations with ",(0,a.jsx)(n.code,{children:"useMutation"})]}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"useMutation"})," hook is used for creating, updating, or deleting data. Here\u2019s an example:"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// src/hooks/useUpdateUser.ts\nimport { useMutation } from "react-query";\nimport { trpc } from "../utils/trpc";\n\nexport const useUpdateUser = () => {\n  return useMutation((userData: { id: string; name: string }) =>\n    trpc.user.updateUser.mutate(userData),\n  );\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"In this example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"useMutation"})," takes a function that performs the mutation (e.g., ",(0,a.jsx)(n.code,{children:"trpc.user.updateUser.mutate"}),")."]}),"\n",(0,a.jsx)(n.li,{children:"You can handle success, error, and loading states using the returned object."}),"\n"]}),"\n",(0,a.jsxs)(n.h3,{id:"manual-cache-management-with-usequeryclient",children:["Manual Cache Management with ",(0,a.jsx)(n.code,{children:"useQueryClient"})]}),"\n",(0,a.jsxs)(n.p,{children:["Sometimes, you may need to manually invalidate or update the cache. Here\u2019s how to use ",(0,a.jsx)(n.code,{children:"useQueryClient"}),":"]}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-typescript",children:'// src/hooks/useInvalidateUserCache.ts\nimport { useQueryClient } from "react-query";\n\nexport const useInvalidateUserCache = () => {\n  const queryClient = useQueryClient();\n\n  return (id: string) => {\n    queryClient.invalidateQueries(["user", id]);\n  };\n};\n'})}),"\n",(0,a.jsx)(n.p,{children:"In this example:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"useQueryClient"})})," provides access to the React Query client."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.strong,{children:(0,a.jsx)(n.code,{children:"invalidateQueries"})})," is used to manually invalidate and refetch data for a specific query key."]}),"\n"]}),"\n",(0,a.jsxs)(n.admonition,{type:"note",children:[(0,a.jsx)(n.h2,{id:"invalidating-stale-data",children:"Invalidating Stale Data"}),(0,a.jsx)(n.p,{children:"Invalidating stale data ensures that React Query refetches data to reflect the latest state from the server. This is especially useful for ensuring consistency after a mutation or when specific data may have changed."})]}),"\n",(0,a.jsx)(n.hr,{})]})}function u(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}}}]);