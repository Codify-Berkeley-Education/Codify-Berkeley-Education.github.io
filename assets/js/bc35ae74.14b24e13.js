"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[5077],{6336(e,n,i){i.r(n),i.d(n,{assets:()=>l,contentTitle:()=>s,default:()=>u,frontMatter:()=>o,metadata:()=>r,toc:()=>d});var t=i(4848),a=i(8453);i(1470),i(9365);const o={title:"7.3 - Validation with Zod",metadata:["Can be provided",{as:"objects",or:"arrays"}]},s=void 0,r={id:"Readings/forms-and-validation/7.3",title:"7.3 - Validation with Zod",description:"Zod is a validation and schema declaration library in TypeScript. Zod can be used with React Hook Forms. It can replace React Hook Form's validation, having validation taken care of where the form's schema is defined. Zod comes with a few built-in validation functions.",source:"@site/docs/Readings/7-forms-and-validation/7.3.md",sourceDirName:"Readings/7-forms-and-validation",slug:"/Readings/forms-and-validation/7.3",permalink:"/docs/Readings/forms-and-validation/7.3",draft:!1,unlisted:!1,editUrl:"https://github.com/CS61D/website/tree/main/docs/Readings/7-forms-and-validation/7.3.md",tags:[],version:"current",frontMatter:{title:"7.3 - Validation with Zod",metadata:["Can be provided",{as:"objects",or:"arrays"}]},sidebar:"tutorialSidebar",previous:{title:"7.2 - React Hook Form",permalink:"/docs/Readings/forms-and-validation/7.2"},next:{title:"Lecture 10 - Relational Databases and Data Modeling",permalink:"/docs/Readings/relational-databases-data-modeling/"}},l={},d=[{value:"What is Zod?",id:"what-is-zod",level:3},{value:"Incorporating Zod",id:"incorporating-zod",level:3},{value:"Zod Validation",id:"zod-validation",level:3},{value:"Required and Optional Fields",id:"required-and-optional-fields",level:4},{value:"Built-in Email Validation",id:"built-in-email-validation",level:4},{value:"Custom Validation Logic",id:"custom-validation-logic",level:4},{value:"Involving a Single Field",id:"involving-a-single-field",level:5},{value:"Involving Multiple Fields",id:"involving-multiple-fields",level:5},{value:"Regex and Chaining Validation Rules",id:"regex-and-chaining-validation-rules",level:4},{value:"Wrap Up",id:"wrap-up",level:3}];function c(e){const n={a:"a",code:"code",h3:"h3",h4:"h4",h5:"h5",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",span:"span",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.p,{children:"Zod is a validation and schema declaration library in TypeScript. Zod can be used with React Hook Forms. It can replace React Hook Form's validation, having validation taken care of where the form's schema is defined. Zod comes with a few built-in validation functions."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"what-is-zod",children:"What is Zod?"}),"\n",(0,t.jsxs)(n.p,{children:["Zod is a validation and schema declaration library that can be used with React Hook Form. It is written in TypeScript. With Zod, you must define a schema that describes the shape and contraints of your data. Zod replaces parts of React Hook Form's validation, moving it away from ",(0,t.jsx)(n.code,{children:"register"})," and to the same place as your schema definition. This creates a nice centralized place for validation logic, separate from where your form elements live."]}),"\n",(0,t.jsx)(n.p,{children:"Zod also has built-in validation methods."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"incorporating-zod",children:"Incorporating Zod"}),"\n",(0,t.jsx)(n.p,{children:"Here is an old example using only React Hook Forms:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useForm, SubmitHandler } from "react-hook-form"\n\ntype Inputs = {\n  name: string\n  pet: string\n  subscribe: boolean\n}\n\nexport default function App() {\n  const { register, handleSubmit, formState: { errors }} = useForm<Inputs>()\n  const onSubmit: SubmitHandler<Inputs> = (data) => console.log(data)\n\n  return (\n    <form onSubmit={handleSubmit(onSubmit)}>\n      <label htmlFor="name">Name</label>\n      <input type="text" id="name" {...register("name")} />\n      {errors.name && <p>errors.name.message</p>}\n\n      <label htmlFor="pet">Choose a pet:</label>\n      <select id="pet" {...register("pet")} />\n        <option value="">---Choose an option---</option>\n        <option value="dog">Dog</option>\n        <option value="cat">Cat</option>\n        <option value="hamster">Hamster</option>\n      </select>\n      {errors.pet && <p>errors.pet.message</p>}\n\n      <label htmlFor="subscribe">Subscribe to our email newsletter:</label>\n      <input {...register("subscribe")} id="subscribe" type="checkbox" />\n\n      <button type="submit">Submit</button>\n    </form>\n  )\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"To integrate Zod"})," (without validation stuff yet), you will:"]}),"\n",(0,t.jsxs)(n.ol,{children:["\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Import"})," ",(0,t.jsx)(n.code,{children:"zod"})," and ",(0,t.jsx)(n.code,{children:"zodResolver"})]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Define"})," your schema"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Infer"})," off the schema to create your custom type"]}),"\n",(0,t.jsxs)(n.li,{children:[(0,t.jsx)(n.strong,{children:"Pass in"})," ",(0,t.jsx)(n.code,{children:"zodResolver"})," to ",(0,t.jsx)(n.code,{children:"useForm"})," so that React Hook Form knows to use Zod"]}),"\n"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'import { useForm, SubmitHandler } from "react-hook-form"\n// 1. Import zod and zodResolver\nimport { z } from "zod";\nimport { zodResolver } from "@hookform/resolvers/zod";\n\n// 2. Define you schema\nconst schema = z.object({\n  name: z.string(),\n  pet: z.string(),\n  subscribed: z.boolean()\n})\n\n// 3. Infer off the schema to create your custom type, rather than defining it like before\ntype Inputs = z.infer<typeof schema>\n\nexport default function App() {\n const {\n   register,\n   handleSubmit,\n   formState: { errors },\n } = useForm<Inputs>({\n  // 4. Pass in zodResolver to useForm so that React Hook Form knows to use Zod\n  resolver: zodResolver(schema)\n })\n ...\n}\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"zod-validation",children:"Zod Validation"}),"\n",(0,t.jsxs)(n.p,{children:["Zod validation can completely replace the validation we covered previously with plain React Hook Form. Before, we would pass in validation rules into ",(0,t.jsx)(n.code,{children:"register"}),". Now, with Zod, we will handle validation as we define our schema."]}),"\n",(0,t.jsxs)(n.p,{children:["Zod has a variety of validation methods. ",(0,t.jsxs)(n.strong,{children:["See ",(0,t.jsxs)(n.a,{href:"https://zod.dev",rel:"nofollow",children:["the documentation",(0,t.jsx)(n.span,{children:(0,t.jsx)(n.span,{className:"glossary-icon",children:" \u2197"})})]})," for a full list of Zod validation methods."]})]}),"\n",(0,t.jsx)(n.h4,{id:"required-and-optional-fields",children:"Required and Optional Fields"}),"\n",(0,t.jsxs)(n.p,{children:["Here, we designate the ",(0,t.jsx)(n.code,{children:"name"})," field to be a required field by using the ",(0,t.jsx)(n.code,{children:".min()"})," validation method. While there is no ",(0,t.jsx)(n.code,{children:".required()"})," validation method in Zod, using ",(0,t.jsx)(n.code,{children:".min()"})," and passing in 1 as the minimum character length serves the same purpose ",(0,t.jsxs)(n.strong,{children:["for fields of type ",(0,t.jsx)(n.code,{children:"string"}),"."]})]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const schema = z.object({\n  name: z.string().min(1, "Name is required"),\n  pet: z.string().optional(),\n  subscribed: z.boolean(),\n});\n'})}),"\n",(0,t.jsxs)(n.p,{children:["We also designate the ",(0,t.jsx)(n.code,{children:"pet"})," field to be optional by calling the ",(0,t.jsx)(n.code,{children:".optional()"})," method. ",(0,t.jsxs)(n.strong,{children:["By default, Zod will make fields required, unless you explicitly make them optional by calling the ",(0,t.jsx)(n.code,{children:".optional()"})," method."]})]}),"\n",(0,t.jsxs)(n.p,{children:["You might wonder why we call ",(0,t.jsx)(n.code,{children:'.min(1, "Name is required")'})," on the ",(0,t.jsx)(n.code,{children:"name"})," field if Zod just makes fields required by default. This is because the empty string (",(0,t.jsx)(n.code,{children:'""'}),") is technically a valid input for a required field. ",(0,t.jsx)(n.strong,{children:"In React Hook Forms, an empty input field results in an empty string."})," To prevent empty strings, we tack on ",(0,t.jsx)(n.code,{children:".min()"}),'. Additionally, this lets us add a custom "Name is required" error message.']}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"built-in-email-validation",children:"Built-in Email Validation"}),"\n",(0,t.jsxs)(n.p,{children:["Zod has built-in email validation for ",(0,t.jsx)(n.code,{children:"string"})," fields:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const schema = z.object({\n  name: z.string().min(1, "Name is required"),\n  pet: z.string().optional(),\n  subscribed: z.boolean(),\n  email: z.string().email(),\n});\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h4,{id:"custom-validation-logic",children:"Custom Validation Logic"}),"\n",(0,t.jsxs)(n.p,{children:["In Zod, the ",(0,t.jsx)(n.code,{children:".refine()"})," method is used to apply custom validation logic to a schema. Recall that with plain React Hook Form, this can be done by setting ",(0,t.jsx)(n.code,{children:"validate"})," to a custom validation function when you ",(0,t.jsx)(n.code,{children:"register"})," a field. ",(0,t.jsx)(n.code,{children:".refine()"})," replaces this old method."]}),"\n",(0,t.jsx)(n.h5,{id:"involving-a-single-field",children:"Involving a Single Field"}),"\n",(0,t.jsxs)(n.p,{children:["If your custom validation function deals with a single field, call ",(0,t.jsx)(n.code,{children:".refine()"})," like you would with the other validation methods so far. Pass in your custom validation function into ",(0,t.jsx)(n.code,{children:".refine()"}),". Also pass in your custom error message."]}),"\n",(0,t.jsxs)(n.p,{children:["Your custom validation function should take in a field's data, return ",(0,t.jsx)(n.code,{children:"true"})," if valid or ",(0,t.jsx)(n.code,{children:"false"})," otherwise."]}),"\n",(0,t.jsx)(n.p,{children:"This example's custom validation function makes sure that the user does not input a date of birth that is in the future."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const schema = z.object({\n  dateOfBirth: z.string().refine((date) => {\n    const today = new Date().toISOString().slice(0, 10);\n    return date <= today;\n  }, "Date cannot be in the future"),\n  // <input type="date">\n  // refine placed here because it\u2019s only accessing one field\n});\n'})}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h5,{id:"involving-multiple-fields",children:"Involving Multiple Fields"}),"\n",(0,t.jsxs)(n.p,{children:["If your custom validation function deals with multiple fields, call ",(0,t.jsx)(n.code,{children:".refine()"})," after your ",(0,t.jsx)(n.code,{children:".object()"})," call. This example's custom validation function checks if the user inputted the same email for both the ",(0,t.jsx)(n.code,{children:"email"})," and ",(0,t.jsx)(n.code,{children:"confirmEmail"})," fields."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const schema = z\n  .object({\n    email: z.string().email(),\n    confirmEmail: z.string().email(),\n  })\n  .refine((data) => data.email === data.confirmEmail, {\n    message: "Emails don\'t match",\n    path: ["confirmEmail"],\n  }); // refine is placed after .object because we are\n// accessing multiple fields\n'})}),"\n",(0,t.jsxs)(n.p,{children:["Again, pass your custom validation function into ",(0,t.jsx)(n.code,{children:".refine()"})," as the first argument. This time, ",(0,t.jsx)(n.strong,{children:"your custom validation function should take in the entire form's data"})," (which is an object). Use dot notation to access an individual field's data."]}),"\n",(0,t.jsxs)(n.p,{children:["The second argument to ",(0,t.jsx)(n.code,{children:".refine()"})," is an object in which you can pass in your custom error message through the ",(0,t.jsx)(n.code,{children:"message"})," key, as well as the field(s) which the validation function and error message should pertain to through the ",(0,t.jsx)(n.code,{children:"path"})," key."]}),"\n",(0,t.jsx)(n.h4,{id:"regex-and-chaining-validation-rules",children:"Regex and Chaining Validation Rules"}),"\n",(0,t.jsxs)(n.p,{children:["Zod's ",(0,t.jsx)(n.code,{children:".regex()"})," validation method applies the given regex pattern onto the form data to see if it is valid."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-tsx",children:'const schema = z.object({\n  password: z.\n    .string()\n    .min(1, "Password is required")\n    .regex(/[a-z]/, "Password must contain at least one lowercase letter")\n    .regex(/[A-Z]/, "Password must contain at least one uppercase letter")\n})\n'})}),"\n",(0,t.jsx)(n.p,{children:"Like we've seen before, Zod validation methods can be chained."}),"\n",(0,t.jsx)(n.hr,{}),"\n",(0,t.jsx)(n.h3,{id:"wrap-up",children:"Wrap Up"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["Now with Zod, all validation on our form data is taken care of at the top of our file as part of the schema definition. It is no longer written inside each field's ",(0,t.jsx)(n.code,{children:"register"}),"."]}),"\n",(0,t.jsx)(n.li,{children:"Displaying error messages is still the same as with plain React Hook Form."}),"\n",(0,t.jsx)(n.li,{children:"Zod comes with built-in validation methods (e.g. email)"}),"\n",(0,t.jsx)(n.li,{children:"Zod allows us to cleanly chain validation methods and write custom validation logic."}),"\n"]})]})}function u(e={}){const{wrapper:n}={...(0,a.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(c,{...e})}):c(e)}},9365(e,n,i){i.d(n,{A:()=>s});i(6540);var t=i(4164);const a="tabItem_Ymn6";var o=i(4848);function s({children:e,hidden:n,className:i}){return(0,o.jsx)("div",{role:"tabpanel",className:(0,t.A)(a,i),hidden:n,children:e})}},1470(e,n,i){i.d(n,{A:()=>k});var t=i(6540),a=i(4164),o=i(3104),s=i(6347),r=i(205),l=i(7485),d=i(1682),c=i(9466);function u(e){return t.Children.toArray(e).filter(e=>"\n"!==e).map(e=>{if(!e||(0,t.isValidElement)(e)&&function(e){const{props:n}=e;return!!n&&"object"==typeof n&&"value"in n}(e))return e;throw new Error(`Docusaurus error: Bad <Tabs> child <${"string"==typeof e.type?e.type:e.type.name}>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.`)})?.filter(Boolean)??[]}function h(e){const{values:n,children:i}=e;return(0,t.useMemo)(()=>{const e=n??function(e){return u(e).map(({props:{value:e,label:n,attributes:i,default:t}})=>({value:e,label:n,attributes:i,default:t}))}(i);return function(e){const n=(0,d.X)(e,(e,n)=>e.value===n.value);if(n.length>0)throw new Error(`Docusaurus error: Duplicate values "${n.map(e=>e.value).join(", ")}" found in <Tabs>. Every value needs to be unique.`)}(e),e},[n,i])}function m({value:e,tabValues:n}){return n.some(n=>n.value===e)}function p({queryString:e=!1,groupId:n}){const i=(0,s.W6)(),a=function({queryString:e=!1,groupId:n}){if("string"==typeof e)return e;if(!1===e)return null;if(!0===e&&!n)throw new Error('Docusaurus error: The <Tabs> component groupId prop is required if queryString=true, because this value is used as the search param name. You can also provide an explicit value such as queryString="my-search-param".');return n??null}({queryString:e,groupId:n});return[(0,l.aZ)(a),(0,t.useCallback)(e=>{if(!a)return;const n=new URLSearchParams(i.location.search);n.set(a,e),i.replace({...i.location,search:n.toString()})},[a,i])]}function f(e){const{defaultValue:n,queryString:i=!1,groupId:a}=e,o=h(e),[s,l]=(0,t.useState)(()=>function({defaultValue:e,tabValues:n}){if(0===n.length)throw new Error("Docusaurus error: the <Tabs> component requires at least one <TabItem> children component");if(e){if(!m({value:e,tabValues:n}))throw new Error(`Docusaurus error: The <Tabs> has a defaultValue "${e}" but none of its children has the corresponding value. Available values are: ${n.map(e=>e.value).join(", ")}. If you intend to show no default tab, use defaultValue={null} instead.`);return e}const i=n.find(e=>e.default)??n[0];if(!i)throw new Error("Unexpected error: 0 tabValues");return i.value}({defaultValue:n,tabValues:o})),[d,u]=p({queryString:i,groupId:a}),[f,g]=function({groupId:e}){const n=function(e){return e?`docusaurus.tab.${e}`:null}(e),[i,a]=(0,c.Dv)(n);return[i,(0,t.useCallback)(e=>{n&&a.set(e)},[n,a])]}({groupId:a}),v=(()=>{const e=d??f;return m({value:e,tabValues:o})?e:null})();(0,r.A)(()=>{v&&l(v)},[v]);return{selectedValue:s,selectValue:(0,t.useCallback)(e=>{if(!m({value:e,tabValues:o}))throw new Error(`Can't select invalid tab value=${e}`);l(e),u(e),g(e)},[u,g,o]),tabValues:o}}var g=i(2303);const v="tabList__CuJ",x="tabItem_LNqP";var b=i(4848);function j({className:e,block:n,selectedValue:i,selectValue:t,tabValues:s}){const r=[],{blockElementScrollPositionUntilNextRender:l}=(0,o.a_)(),d=e=>{const n=e.currentTarget,a=r.indexOf(n),o=s[a].value;o!==i&&(l(n),t(o))},c=e=>{let n=null;switch(e.key){case"Enter":d(e);break;case"ArrowRight":{const i=r.indexOf(e.currentTarget)+1;n=r[i]??r[0];break}case"ArrowLeft":{const i=r.indexOf(e.currentTarget)-1;n=r[i]??r[r.length-1];break}}n?.focus()};return(0,b.jsx)("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,a.A)("tabs",{"tabs--block":n},e),children:s.map(({value:e,label:n,attributes:t})=>(0,b.jsx)("li",{role:"tab",tabIndex:i===e?0:-1,"aria-selected":i===e,ref:e=>r.push(e),onKeyDown:c,onClick:d,...t,className:(0,a.A)("tabs__item",x,t?.className,{"tabs__item--active":i===e}),children:n??e},e))})}function y({lazy:e,children:n,selectedValue:i}){const a=(Array.isArray(n)?n:[n]).filter(Boolean);if(e){const e=a.find(e=>e.props.value===i);return e?(0,t.cloneElement)(e,{className:"margin-top--md"}):null}return(0,b.jsx)("div",{className:"margin-top--md",children:a.map((e,n)=>(0,t.cloneElement)(e,{key:n,hidden:e.props.value!==i}))})}function w(e){const n=f(e);return(0,b.jsxs)("div",{className:(0,a.A)("tabs-container",v),children:[(0,b.jsx)(j,{...e,...n}),(0,b.jsx)(y,{...e,...n})]})}function k(e){const n=(0,g.A)();return(0,b.jsx)(w,{...e,children:u(e.children)},String(n))}},8453(e,n,i){i.d(n,{R:()=>s,x:()=>r});var t=i(6540);const a={},o=t.createContext(a);function s(e){const n=t.useContext(o);return t.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:s(e.components),t.createElement(o.Provider,{value:n},e.children)}}}]);