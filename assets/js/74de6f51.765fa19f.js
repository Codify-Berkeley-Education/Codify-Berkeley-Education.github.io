"use strict";(globalThis.webpackChunkwebsite=globalThis.webpackChunkwebsite||[]).push([[8485],{2764(e,n,t){t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>o,default:()=>h,frontMatter:()=>a,metadata:()=>l,toc:()=>d});var i=t(4848),s=t(8453);const a={sidebar_position:6},o="Tailwind CSS",l={id:"Readings/tailwind",title:"Tailwind CSS",description:'"There are only two hard things in Computer Science: cache invalidation and naming things."',source:"@site/docs/Readings/tailwind.md",sourceDirName:"Readings",slug:"/Readings/tailwind",permalink:"/docs/Readings/tailwind",draft:!1,unlisted:!1,editUrl:"https://github.com/CS61D/website/tree/main/docs/Readings/tailwind.md",tags:[],version:"current",sidebarPosition:6,frontMatter:{sidebar_position:6},sidebar:"tutorialSidebar",previous:{title:"6.4 - Custom Hooks",permalink:"/docs/Readings/advanced-state-management/6.4"},next:{title:"Lecture 7: Forms and Validation",permalink:"/docs/Readings/forms-and-validation/"}},r={},d=[{value:"CSS Introduction",id:"css-introduction",level:2},{value:"Tailwind CSS",id:"tailwind-css-1",level:2}];function c(e){const n={blockquote:"blockquote",code:"code",em:"em",h1:"h1",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"tailwind-css",children:"Tailwind CSS"}),"\n",(0,i.jsxs)(n.blockquote,{children:["\n",(0,i.jsx)(n.p,{children:'"There are only two hard things in Computer Science: cache invalidation and naming things."'}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"-- Phil Karlton, early developer of Netscape Navigator, the first commercial web browser"}),"\n",(0,i.jsx)(n.h2,{id:"css-introduction",children:"CSS Introduction"}),"\n",(0,i.jsx)(n.p,{children:"The web is styled using CSS (Cascading Style Sheets). Properties are applied to HTML elements to change their color, size, padding, and layout. The traditional way to of writing CSS is to create separate CSS files defining classes and then applying those classes to HTML elements."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-css",metastring:'titel="styles.css"',children:".heading {\n  font-weight: bold;\n  color: blue;\n  font-size: xx-large;\n}\n"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'// Import the CSS file in the component\nimport "./App.css";\n\nexport default function App() {\n  return (\n    <div>\n      {/* Use the css property*/}\n      <h1 className="heading">Dice Roller</h1>\n\n      {/* Rest of app omitted*/}\n    </div>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"However, this approach leads to several problems:"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Naming (see quote)"}),": Coming up with accurate and descriptive class names can be difficult. There are no standard naming conventions between projects."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Unused CSS"}),": As the project grows, CSS classes which are no longer used will still be bundled with the application and sent to the client."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cumbersome development workflow"}),": Tabbing back and forth between HTML and CSS files causes unnecessary context switching."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:["Most importantly, the traditional approach is not oriented around the fundamental mental model used in React Development: components. Components are designed to be self contained reusable units of code. We don't really care about reusing CSS classes, we care about reusing the ",(0,i.jsx)(n.em,{children:"all"})," of the markup, styling, and logic of a component."]}),"\n",(0,i.jsx)(n.h2,{id:"tailwind-css-1",children:"Tailwind CSS"}),"\n",(0,i.jsx)(n.p,{children:"Tailwind CSS solves all of these problems. All it is is a set of pre-defined utility classes, which can be applied directly to HTML elements. These utility classes closely mirror the underlying CSS properties, meaning that it you can start using it effortlessly if you are already familiar with CSS. It also means you can just start using Tailwind without having ever written any CSS before, and you will learn the underlying CSS properties as you learn Tailwind."}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-tsx",metastring:'title="App.tsx"',children:'export default function App() {\n  return (\n    <div>\n      {/* Use the css property*/}\n      <h1 className="font-bold text-blue-500 text-2xl">Dice Roller</h1>\n\n      {/* Rest of app omitted*/}\n    </div>\n  );\n}\n'})}),"\n",(0,i.jsx)(n.p,{children:"Tailwind's default class names are consistent between projects, making them easy to remember and use (solving the naming problem). Writing class names directly in the markup turns our components into truly self contained units which do not require looking at multiple files to understand (solving the context switching problem). Finally, Tailwind only includes class names that are actually used in the final build, meaning that unused CSS is not sent to the client (solving the unused CSS problem)."}),"\n",(0,i.jsx)(n.p,{children:"As a result of these benefits, Tailwind has become the default way of writing CSS on the web."})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453(e,n,t){t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const s={},a=i.createContext(s);function o(e){const n=i.useContext(a);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:o(e.components),i.createElement(a.Provider,{value:n},e.children)}}}]);